-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://redmine.postgresql.org/projects/pgadmin4/issues/new if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS public.ab_permission
(
    id integer NOT NULL DEFAULT 'nextval('ab_permission_id_seq'::regclass)',
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT ab_permission_pkey PRIMARY KEY (id),
    CONSTRAINT ab_permission_name_key UNIQUE (name)
);

CREATE TABLE IF NOT EXISTS public.ab_permission_view
(
    id integer NOT NULL DEFAULT 'nextval('ab_permission_view_id_seq'::regclass)',
    permission_id integer,
    view_menu_id integer,
    CONSTRAINT ab_permission_view_pkey PRIMARY KEY (id),
    CONSTRAINT ab_permission_view_permission_id_view_menu_id_key UNIQUE (permission_id, view_menu_id)
);

CREATE TABLE IF NOT EXISTS public.ab_permission_view_role
(
    id integer NOT NULL DEFAULT 'nextval('ab_permission_view_role_id_seq'::regclass)',
    permission_view_id integer,
    role_id integer,
    CONSTRAINT ab_permission_view_role_pkey PRIMARY KEY (id),
    CONSTRAINT ab_permission_view_role_permission_view_id_role_id_key UNIQUE (permission_view_id, role_id)
);

CREATE TABLE IF NOT EXISTS public.ab_register_user
(
    id integer NOT NULL DEFAULT 'nextval('ab_register_user_id_seq'::regclass)',
    first_name character varying(64) COLLATE pg_catalog."default" NOT NULL,
    last_name character varying(64) COLLATE pg_catalog."default" NOT NULL,
    username character varying(64) COLLATE pg_catalog."default" NOT NULL,
    password character varying(256) COLLATE pg_catalog."default",
    email character varying(64) COLLATE pg_catalog."default" NOT NULL,
    registration_date timestamp without time zone,
    registration_hash character varying(256) COLLATE pg_catalog."default",
    CONSTRAINT ab_register_user_pkey PRIMARY KEY (id),
    CONSTRAINT ab_register_user_username_key UNIQUE (username)
);

CREATE TABLE IF NOT EXISTS public.ab_role
(
    id integer NOT NULL DEFAULT 'nextval('ab_role_id_seq'::regclass)',
    name character varying(64) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT ab_role_pkey PRIMARY KEY (id),
    CONSTRAINT ab_role_name_key UNIQUE (name)
);

CREATE TABLE IF NOT EXISTS public.ab_user
(
    id integer NOT NULL DEFAULT 'nextval('ab_user_id_seq'::regclass)',
    first_name character varying(64) COLLATE pg_catalog."default" NOT NULL,
    last_name character varying(64) COLLATE pg_catalog."default" NOT NULL,
    username character varying(64) COLLATE pg_catalog."default" NOT NULL,
    password character varying(256) COLLATE pg_catalog."default",
    active boolean,
    email character varying(64) COLLATE pg_catalog."default" NOT NULL,
    last_login timestamp without time zone,
    login_count integer,
    fail_login_count integer,
    created_on timestamp without time zone,
    changed_on timestamp without time zone,
    created_by_fk integer,
    changed_by_fk integer,
    CONSTRAINT ab_user_pkey PRIMARY KEY (id),
    CONSTRAINT ab_user_email_key UNIQUE (email),
    CONSTRAINT ab_user_username_key UNIQUE (username)
);

CREATE TABLE IF NOT EXISTS public.ab_user_role
(
    id integer NOT NULL DEFAULT 'nextval('ab_user_role_id_seq'::regclass)',
    user_id integer,
    role_id integer,
    CONSTRAINT ab_user_role_pkey PRIMARY KEY (id),
    CONSTRAINT ab_user_role_user_id_role_id_key UNIQUE (user_id, role_id)
);

CREATE TABLE IF NOT EXISTS public.ab_view_menu
(
    id integer NOT NULL DEFAULT 'nextval('ab_view_menu_id_seq'::regclass)',
    name character varying(250) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT ab_view_menu_pkey PRIMARY KEY (id),
    CONSTRAINT ab_view_menu_name_key UNIQUE (name)
);

CREATE TABLE IF NOT EXISTS public.alembic_version
(
    version_num character varying(32) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)
);

CREATE TABLE IF NOT EXISTS public.connection
(
    id integer NOT NULL DEFAULT 'nextval('connection_id_seq'::regclass)',
    conn_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    conn_type character varying(500) COLLATE pg_catalog."default" NOT NULL,
    host character varying(500) COLLATE pg_catalog."default",
    schema character varying(500) COLLATE pg_catalog."default",
    login character varying(500) COLLATE pg_catalog."default",
    password character varying(5000) COLLATE pg_catalog."default",
    port integer,
    extra character varying(5000) COLLATE pg_catalog."default",
    is_encrypted boolean,
    is_extra_encrypted boolean,
    description text COLLATE pg_catalog."default",
    CONSTRAINT connection_pkey PRIMARY KEY (id),
    CONSTRAINT unique_conn_id UNIQUE (conn_id)
);

CREATE TABLE IF NOT EXISTS public.dag
(
    dag_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    is_paused boolean,
    is_subdag boolean,
    is_active boolean,
    last_scheduler_run timestamp with time zone,
    last_pickled timestamp with time zone,
    last_expired timestamp with time zone,
    scheduler_lock boolean,
    pickle_id integer,
    fileloc character varying(2000) COLLATE pg_catalog."default",
    owners character varying(2000) COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default",
    default_view character varying(25) COLLATE pg_catalog."default",
    schedule_interval text COLLATE pg_catalog."default",
    root_dag_id character varying(250) COLLATE pg_catalog."default",
    next_dagrun timestamp with time zone,
    next_dagrun_create_after timestamp with time zone,
    concurrency integer NOT NULL,
    has_task_concurrency_limits boolean NOT NULL,
    CONSTRAINT dag_pkey PRIMARY KEY (dag_id)
);

CREATE TABLE IF NOT EXISTS public.dag_code
(
    fileloc_hash bigint NOT NULL,
    fileloc character varying(2000) COLLATE pg_catalog."default" NOT NULL,
    source_code text COLLATE pg_catalog."default" NOT NULL,
    last_updated timestamp with time zone NOT NULL,
    CONSTRAINT dag_code_pkey PRIMARY KEY (fileloc_hash)
);

CREATE TABLE IF NOT EXISTS public.dag_pickle
(
    id integer NOT NULL DEFAULT 'nextval('dag_pickle_id_seq'::regclass)',
    pickle bytea,
    created_dttm timestamp with time zone,
    pickle_hash bigint,
    CONSTRAINT dag_pickle_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.dag_run
(
    id integer NOT NULL DEFAULT 'nextval('dag_run_id_seq'::regclass)',
    dag_id character varying(250) COLLATE pg_catalog."default",
    execution_date timestamp with time zone,
    state character varying(50) COLLATE pg_catalog."default",
    run_id character varying(250) COLLATE pg_catalog."default",
    external_trigger boolean,
    conf bytea,
    end_date timestamp with time zone,
    start_date timestamp with time zone,
    run_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    last_scheduling_decision timestamp with time zone,
    dag_hash character varying(32) COLLATE pg_catalog."default",
    creating_job_id integer,
    CONSTRAINT dag_run_pkey PRIMARY KEY (id),
    CONSTRAINT dag_run_dag_id_execution_date_key UNIQUE (dag_id, execution_date),
    CONSTRAINT dag_run_dag_id_run_id_key UNIQUE (dag_id, run_id)
);

CREATE TABLE IF NOT EXISTS public.dag_tag
(
    name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    dag_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT dag_tag_pkey PRIMARY KEY (name, dag_id)
);

CREATE TABLE IF NOT EXISTS public.import_error
(
    id integer NOT NULL DEFAULT 'nextval('import_error_id_seq'::regclass)',
    "timestamp" timestamp with time zone,
    filename character varying(1024) COLLATE pg_catalog."default",
    stacktrace text COLLATE pg_catalog."default",
    CONSTRAINT import_error_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.job
(
    id integer NOT NULL DEFAULT 'nextval('job_id_seq'::regclass)',
    dag_id character varying(250) COLLATE pg_catalog."default",
    state character varying(20) COLLATE pg_catalog."default",
    job_type character varying(30) COLLATE pg_catalog."default",
    start_date timestamp with time zone,
    end_date timestamp with time zone,
    latest_heartbeat timestamp with time zone,
    executor_class character varying(500) COLLATE pg_catalog."default",
    hostname character varying(500) COLLATE pg_catalog."default",
    unixname character varying(1000) COLLATE pg_catalog."default",
    CONSTRAINT job_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.log
(
    id integer NOT NULL DEFAULT 'nextval('log_id_seq'::regclass)',
    dttm timestamp with time zone,
    dag_id character varying(250) COLLATE pg_catalog."default",
    task_id character varying(250) COLLATE pg_catalog."default",
    event character varying(30) COLLATE pg_catalog."default",
    execution_date timestamp with time zone,
    owner character varying(500) COLLATE pg_catalog."default",
    extra text COLLATE pg_catalog."default",
    CONSTRAINT log_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.rendered_task_instance_fields
(
    dag_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    task_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    execution_date timestamp with time zone NOT NULL,
    rendered_fields json NOT NULL,
    k8s_pod_yaml json,
    CONSTRAINT rendered_task_instance_fields_pkey PRIMARY KEY (dag_id, task_id, execution_date)
);

CREATE TABLE IF NOT EXISTS public.sensor_instance
(
    id integer NOT NULL DEFAULT 'nextval('sensor_instance_id_seq'::regclass)',
    task_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    dag_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    execution_date timestamp with time zone NOT NULL,
    state character varying(20) COLLATE pg_catalog."default",
    try_number integer,
    start_date timestamp with time zone,
    operator character varying(1000) COLLATE pg_catalog."default" NOT NULL,
    op_classpath character varying(1000) COLLATE pg_catalog."default" NOT NULL,
    hashcode bigint NOT NULL,
    shardcode integer NOT NULL,
    poke_context text COLLATE pg_catalog."default" NOT NULL,
    execution_context text COLLATE pg_catalog."default",
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    CONSTRAINT sensor_instance_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.serialized_dag
(
    dag_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    fileloc character varying(2000) COLLATE pg_catalog."default" NOT NULL,
    fileloc_hash bigint NOT NULL,
    data json NOT NULL,
    last_updated timestamp with time zone NOT NULL,
    dag_hash character varying(32) COLLATE pg_catalog."default" NOT NULL DEFAULT 'Hash not calculated yet'::character varying,
    CONSTRAINT serialized_dag_pkey PRIMARY KEY (dag_id)
);

CREATE TABLE IF NOT EXISTS public.sla_miss
(
    task_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    dag_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    execution_date timestamp with time zone NOT NULL,
    email_sent boolean,
    "timestamp" timestamp with time zone,
    description text COLLATE pg_catalog."default",
    notification_sent boolean,
    CONSTRAINT sla_miss_pkey PRIMARY KEY (task_id, dag_id, execution_date)
);

CREATE TABLE IF NOT EXISTS public.slot_pool
(
    id integer NOT NULL DEFAULT 'nextval('slot_pool_id_seq'::regclass)',
    pool character varying(256) COLLATE pg_catalog."default",
    slots integer,
    description text COLLATE pg_catalog."default",
    CONSTRAINT slot_pool_pkey PRIMARY KEY (id),
    CONSTRAINT slot_pool_pool_key UNIQUE (pool)
);

CREATE TABLE IF NOT EXISTS public.task_fail
(
    id integer NOT NULL DEFAULT 'nextval('task_fail_id_seq'::regclass)',
    task_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    dag_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    execution_date timestamp with time zone NOT NULL,
    start_date timestamp with time zone,
    end_date timestamp with time zone,
    duration integer,
    CONSTRAINT task_fail_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.task_instance
(
    task_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    dag_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    execution_date timestamp with time zone NOT NULL,
    start_date timestamp with time zone,
    end_date timestamp with time zone,
    duration double precision,
    state character varying(20) COLLATE pg_catalog."default",
    try_number integer,
    hostname character varying(1000) COLLATE pg_catalog."default",
    unixname character varying(1000) COLLATE pg_catalog."default",
    job_id integer,
    pool character varying(50) COLLATE pg_catalog."default" NOT NULL,
    queue character varying(256) COLLATE pg_catalog."default",
    priority_weight integer,
    operator character varying(1000) COLLATE pg_catalog."default",
    queued_dttm timestamp with time zone,
    pid integer,
    max_tries integer DEFAULT '-1'::integer,
    executor_config bytea,
    pool_slots integer,
    queued_by_job_id integer,
    external_executor_id character varying(250) COLLATE pg_catalog."default",
    CONSTRAINT task_instance_pkey PRIMARY KEY (task_id, dag_id, execution_date)
);

CREATE TABLE IF NOT EXISTS public.task_reschedule
(
    id integer NOT NULL DEFAULT 'nextval('task_reschedule_id_seq'::regclass)',
    task_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    dag_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    execution_date timestamp with time zone NOT NULL,
    try_number integer NOT NULL,
    start_date timestamp with time zone NOT NULL,
    end_date timestamp with time zone NOT NULL,
    duration integer NOT NULL,
    reschedule_date timestamp with time zone NOT NULL,
    CONSTRAINT task_reschedule_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.variable
(
    id integer NOT NULL DEFAULT 'nextval('variable_id_seq'::regclass)',
    key character varying(250) COLLATE pg_catalog."default",
    val text COLLATE pg_catalog."default",
    is_encrypted boolean,
    CONSTRAINT variable_pkey PRIMARY KEY (id),
    CONSTRAINT variable_key_key UNIQUE (key)
);

CREATE TABLE IF NOT EXISTS public.xcom
(
    key character varying(512) COLLATE pg_catalog."default" NOT NULL,
    value bytea,
    "timestamp" timestamp with time zone NOT NULL,
    execution_date timestamp with time zone NOT NULL,
    task_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    dag_id character varying(250) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT pk_xcom PRIMARY KEY (dag_id, task_id, key, execution_date)
);

ALTER TABLE IF EXISTS public.ab_permission_view
    ADD CONSTRAINT ab_permission_view_permission_id_fkey FOREIGN KEY (permission_id)
    REFERENCES public.ab_permission (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.ab_permission_view
    ADD CONSTRAINT ab_permission_view_view_menu_id_fkey FOREIGN KEY (view_menu_id)
    REFERENCES public.ab_view_menu (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.ab_permission_view_role
    ADD CONSTRAINT ab_permission_view_role_permission_view_id_fkey FOREIGN KEY (permission_view_id)
    REFERENCES public.ab_permission_view (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.ab_permission_view_role
    ADD CONSTRAINT ab_permission_view_role_role_id_fkey FOREIGN KEY (role_id)
    REFERENCES public.ab_role (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.ab_user
    ADD CONSTRAINT ab_user_changed_by_fk_fkey FOREIGN KEY (changed_by_fk)
    REFERENCES public.ab_user (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.ab_user
    ADD CONSTRAINT ab_user_created_by_fk_fkey FOREIGN KEY (created_by_fk)
    REFERENCES public.ab_user (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.ab_user_role
    ADD CONSTRAINT ab_user_role_role_id_fkey FOREIGN KEY (role_id)
    REFERENCES public.ab_role (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.ab_user_role
    ADD CONSTRAINT ab_user_role_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.ab_user (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.dag_tag
    ADD CONSTRAINT dag_tag_dag_id_fkey FOREIGN KEY (dag_id)
    REFERENCES public.dag (dag_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.task_reschedule
    ADD CONSTRAINT task_reschedule_dag_task_date_fkey FOREIGN KEY (execution_date, task_id, dag_id)
    REFERENCES public.task_instance (execution_date, task_id, dag_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_task_reschedule_dag_task_date
    ON public.task_reschedule(execution_date, task_id, dag_id);

END;